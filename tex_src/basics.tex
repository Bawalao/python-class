
\section{Basics}

Welcome to the first part of the Doudou Python tutorial!  This part
will cover all basic Python primitives including functions, variables,
how they are managed etc. Let's go!

\subsection{Variables}

Python is a (mostly) interpreted dynamically typed language. Why
mostly? Because it is possible to compile Python. We will get into
more details about it in the advanced section. Why dynamically typed?
Because in Python, you don't need to explicitly specify the type of a
variable, it will be deduced based on the value you are assigning the
variable to. Moreover, you can reassign the same variable with a
different type, because the type will dynamically change based on the
value you are assigning to it. Let's look at an example. In Python,
we can use the ``type'' keyword to evaluate the type of a variable.
Also, we will use the ``print'' built-in function, which takes an
``infinite'' number of arguments as input and displays them on the
standard output, separated by spaces.

\begin{lstlisting}[language=python]
a = 5
print(a, 'of type', type(a))
a = 'hello'
print(a, 'of type', type(a))
\end{lstlisting}

Now let's execute this code.

\begin{lstlisting}[language=bash]
doudoush:~$ python3 variable.py
 5 of type <class 'int'>
 hello of type <class 'str'>
doudoush:~$
\end{lstlisting}

While other languages (like C++) would have complained that you cannot assign
the value ``hello'' of type string to the variable ``a'' of type integer, Python
doesn't care and simply reassign the value and the type of the variable.

\vspace{5mm}
Also, remember that as the language is interpreted, you can execute some code before
an error happens. For example, if you forget to define a variable, the error will
be raised only when you try to use this variable/

\begin{lstlisting}[language=python]
blossom = 'commander and the leader'
bubbles = 'the joy and a laugher'

print('Blossom', blossom)
print('Bubbles', bubbles)
print('Buttercup', buttercup)
\end{lstlisting}

Gives the output:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 variables.py
 Blossom commander and the leader
 Bubbles the joy and a laugher
 Traceback (most recent call last):
   File "variables.py", line 12, in <module>
     print('Buttercup', buttercup)
 NameError: name 'buttercup' is not defined
doudoush:~$
\end{lstlisting}

Other languages like C++ would have complained that the variable ``buttercup''
did not exist before printing the two other variables.

\subsection{Combining variables}

Another cool aspect of the Python language is the way you can combine variables.
For example, as with many other languages, you can combine high level types with
lower level types. For example, if you do the sum of an integer and a float,
the result will be a variable of type float:

\begin{lstlisting}[language=python]
cactus = 4
cactus += 0.5

print(cactus, 'of type', type(cactus))
\end{lstlisting}

Outputs:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 variables.py
  4.5 of type <class 'float'>
doudoush:~$
\end{lstlisting}

Pretty obvious yes. But what happens if we try to add an integer to a string?

\begin{lstlisting}[language=python]
cactus = 3
cactus += ' is your lucky number'
\end{lstlisting}

\begin{lstlisting}[language=bash]
doudoush:~$ python3 variables.py
  Traceback (most recent call last):
  File "variables.py", line 2, in <module>
    cactus += ' is your lucky number'
    TypeError: unsupported operand type(s) for +=: 'int' and 'str'
doudoush:~$
\end{lstlisting}

This is because it tries to call the ``+'' operator from the ``int'' primitive type.
However, this operator is not defined for variables of type ``str''. We will get
into more details in the following section about functions.

\vspace{5mm}

You may thus wonder how can we combine strings and integers? Well, there are
several ways. The quick and dirty way is to explicitly cast the variable to
the target type. Of course, it does not make sense to try to cast a string to
an integer, as there is no obvious semantic to this operation. So we will do
the other way around, and try to convert 3 into ``3``. The cast operators are simply
the type of the variable used as a function:

\begin{lstlisting}[language=python]
cactus = 3
cactus = str(cactus) + ' is your lucky number'
print(cactus)
\end{lstlisting}

Which works as expected:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 variables.py
  3 is your lucky number
doudoush:~$
\end{lstlisting}

However, for string there is a much better way of doing this: string formatting!
There are three different ways of doing string formatting: the old way, the modern way
and the very modern way. The old way is a C-style formatting:

\begin{lstlisting}[language=python]
cactus = 3
my_str = '%d is your lucky number' % cactus
\end{lstlisting}

You can also define the way you want the number will be displayed. For example, if you
want to add zeros before the number, you can write ``\%03d'' to specify that
the number should have 3 digits:

\begin{lstlisting}[language=python]
my_str = '%03d is your lucky number' % 3
print(my_str)
my_str = '%03d is our lucky number' % 25
print(my_str)
\end{lstlisting}

Will output:
\begin{lstlisting}[language=bash]
doudoush:~$ python3 variables.py
  003 is your lucky number
  025 is our lucky number
doudoush:~$
\end{lstlisting}

The number got padded with two zeros, and the number twenty five with only one zero,
as it's already a two-digits number.

\vspace{5mm}

Here, the ``\%d'' is the syntax to substitute an entry to an integer. For floating
number, we would use ``\%f'', for string ``\%s''. We can also use this syntax to
substitute multiple variables:

\begin{lstlisting}[language=python]
cactus = 3
kind = 'lucky number'
my_str = '%d is your %s' % (cactus, kind)
\end{lstlisting}


The modern way uses the ``format'' keyword. The main advantage of this method is
that you do not need to specify the type of the variable you want to combine.
We can then write the previous code like this:

\begin{lstlisting}[language=python]
cactus = 3
kind = 'lucky number'
my_str = '{} is your {}'.format(cactus, kind)
\end{lstlisting}

Here, we just need to add ``\{\}'' every time we need to insert a variable. We them
substitute all of these variables as arguments to the format function. We can also
do zeros padding this way:

\begin{lstlisting}[language=python]
cactus = 3
kind = 'lucky number'
my_str = '{:03} is your {}'.format(cactus, kind)
\end{lstlisting}

Finally, the very modern (Python >= 3.6) way does not require the use of the format
function, and uses a new language syntax:

\begin{lstlisting}[language=python]
cactus = 3
kind = 'lucky number'
my_str = f'{cactus:03} is your {kind}'
print(my_str)
\end{lstlisting}

Here, we just need to add the ``f'' character before the string to specify that
this string needs formatting, and we then just add the name of the variable directly
where we want them to appear. This of course gives the same output:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 variables.py
  003 is your lucky number
doudoush:~$
\end{lstlisting}

\subsection{Functions and argument forwarding}
Before going into the important part of this section, let's just take a quick look
at functions in general in Python. First thing first, we create functions using
the ``def'' keyword, as follow:

\begin{lstlisting}[language=python]
def say_hello():
  print('Hello!')
\end{lstlisting}

Note that we indented the code after defining our function. When we increment the
indentation, we create a ``scope''. A scope is kind of a virtual environment where variables live.
When you create a variable within a scope, it only lives in this scope. So if you create
a variable in a function, it will not be available outside of the function. Same happens with
other languages such as C++. However, in C++, scopes are delimited by ``\{\}'', while in Python they
are delimited by indent levels.

\vspace{5mm}

You can use either tabs or spaces for the indentation. However, in a file, as long as you started
using something (say spaces) you cannot use something else later on. I recommend using only spaces,
as editors tend to show tabulations differently (sometimes 2 spaces, sometimes 4).

\vspace{5mm}

Another important thing to know about functions is that functions are also variables. Meaning this
code works perfectly:

\begin{lstlisting}[language=python]
def say_hello():
  print('Hello!')
new_func = say_hello
new_func()
\end{lstlisting}

Last important thing you need to know is that there is no such thing as void functions in Python.
Meaning that all functions in Python return something. I know what you're thinking: ``What? How come?
You didn't return anything here!''. That's true, but Python did. By default, if you do not explicitely
return something, Python returns ``None''. None is a special ``variable'' in Python,
like ``NULL/nullptr'' in C/C++. Like all other variables, it has a type, which is ``NoneType''.
So if we do:

\begin{lstlisting}[language=python]
def say_hello():
  print('Hello!')
new_func = say_hello
result = new_func()
print(type(result))
\end{lstlisting}

We get:
\begin{lstlisting}[language=bash]
doudoush:~$ python3 func.py
  Hello!
  <class 'NoneType'>
doudoush:~$
\end{lstlisting}

You can otherwise return a real result using the ``return'' keyword:

\begin{lstlisting}[language=python]
def say_hello():
  return 'Hello!'

result = say_hello()
print(result)
\end{lstlisting}

\begin{lstlisting}[language=bash]
doudoush:~$ python3 func.py
  Hello!
doudoush:~$
\end{lstlisting}

Also note that there is no static return type in a function, as the language is dynamically typed. You can
then do:

\begin{lstlisting}
def my_func(i):
  if i < 2:
    return True
  return 'cactus'
\end{lstlisting}

That's pretty much all you need to know about functions for now.

\subsubsection{Argument forwarding}

This is the most important part of this section. In this subsection, I will
try to answer as clearly as possible the question ``how the hell are variables
passed in Python?''. The quick answer is ``by assignment''. The useless (but accurate)
answer is ``by un-rebindable reference''. Is that clear?

\vspace{5mm}

No, of course it's not clear. Firstly, you need to know that in
Python, there are mutable and immutable types. Most primitive types
are immutable. If you want to change their value, you must create a
new object. For example, int, float, string, tuples are immutable. You
cannot do:

\begin{lstlisting}[language=python]
cactus = 'hallo'
cactus[1] = 'e'
\end{lstlisting}

You will get the following error message:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 variables.py
  Traceback (most recent call last):
  File "forwarding.py", line 2, in <module>
    a[1] = 'e'
    TypeError: 'str' object does not support item assignment
doudoush:~$
\end{lstlisting}

Lists however are mutable, you can change elements inside a list
(more on that in the data structure section).

\vspace{5mm}

There are two different types of operation: in-place and not in-place.
In place means that the operation is applied directly on the variable, while the later
returns a new variable. You cannot do in-place operations on immutable variables,
which makes sense as they cannot be modified directly.

\vspace{5mm}

Last point before answering the real question, binding the variables. If you don't
remember, binding a variable is the action of linking a variable to its actual value.
Let's first take a look at a quick example:

\begin{lstlisting}[language=python]
a = 5
b = a
b += 1
print('a is', a)
print('b is', b)
\end{lstlisting}

Which gives:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 forwarding.py
  a is 5
  b is 6
doudoush:~$
\end{lstlisting}

Here, ``b'' is a reference on a NEW object with value 5. Thus, changing ``b'' DOES NOT have any impact
on the variable ``a''. You can imagine that when we do ``b = a'', a is actually replaced by its value,
meaning that this code is exactly the same:

\begin{lstlisting}[language=python]
a = 5
b = 5
b += 1
print('a is', a)
print('b is', b)
\end{lstlisting}

Basically, when you create a variable, you are allocating some memory and assigning a reference
to this memory location. You cannot change what this reference is pointing to.

\vspace{5mm}
Now, let's get back to the real problem: how are arguments passed in functions. The answer is by reference.
BUT, without forgetting the rules aforementioned. Let's take a look at a quick example:

\begin{lstlisting}[language=python]
def my_function(my_int, my_list):
  my_list[2] = 5
  my_int += 4
  print('In function', my_int)

my_int = 1
my_list = [0, 1, 2, 3, 4]
my_function(my_int, my_list)
print('my_int', my_int)
print('my_list', my_list)
\end{lstlisting}

Gives:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 forwarding.py
  In function 5
  my_int 1
  my_list [0, 1, 5, 3, 4]
doudoush:~$
\end{lstlisting}

``my\_int'' is immutable. So whatever you do, you cannot change it. ``my\_list'' is mutable,
so we can change the elements inside the list in the function. But what if we tried to
reassign ``my\_list?'' Let's see:

\begin{lstlisting}[language=python]
def my_function(my_int, my_list):
  my_list[2] = 5
  my_int += 4
  print('In function', my_int)
  my_list = [3, 6, 25]
  print('In function', my_list)

my_int = 1
my_list = [0, 1, 2, 3, 4]
my_function(my_int, my_list)
print('my_int', my_int)
print('my_list', my_list)
\end{lstlisting}

Which gives:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 forwarding.py
  In function 5
  In function [3, 6, 25]
  my_int 1
  my_list [0, 1, 5, 3, 4]
doudoush:~$
\end{lstlisting}

So what happened here? Remember what I said? You CANNOT REBIND A REFERENCE.
So basically, you can modify a mutable object, but you cannot reassign it.
When you do ``my\_list += [3, 6, 25]'' you are creating a new local object called ``my\_list''
which ONLY exists in the scope of this function. When we exit the function, the local ``my\_list''
no longer exists, and we are back with the good old ``my\_list'', which, as a nice mutable
object, got modified in the function.

\vspace{5mm}

Soooo, to recap:

\begin{itemize}
\item When you use the ``='' operator, you are creating a new object.
\item When you pass an object to a function, it is passed by reference.
\item If the object is mutable, you can modify it (but not reassign it)
\item If it is immutable, you cannot change it at all.
\end{itemize}

\subsection{Conditions and loop}
I will go very quickly about this part because there is nothing special here.
As for the functions, conditions and loops live in scopes, defined with indent levels.
Conditions are defined with the ``if'' keyword, as follow:

\begin{lstlisting}[language=python]
def is_even(n):
  if n % 2 == 0:
    return True
  return False
\end{lstlisting}

You can also check multiple conditions this way:
\begin{lstlisting}[language=python]
  if something:
    blabla()
  elif something_else:
    blablabla()
  else:
    blibloblablu()
\end{lstlisting}


There are two types of loops in Python: While loops, and for loops. You can exit
these loops using the ``break'' keyword or go the next iteration using the ``continue''
keyword. The first kind of loop repeats a scope of instructions until a criterion is met.

For example:

\begin{lstlisting}
i = 0
while i < 10:
  i += 1
\end{lstlisting}

Here we are incrementing the value of ``i'' by 1 until it reaches 10. Unlike other
languages like C++, there is no ``do-while'' instructions. So here, the condition has
to be true for the code to be executed even the first time.

Let's take a look at the following C++ code:

\begin{lstlisting}[language=C++]
int i = 20;
do
{
  i += 1;
} while(i < 10);
std::cout << i << std::endl;
\end{lstlisting}

If we compile and execute this code inside a main, it will display 21. This is because
the ``do-while'' loop will always execute the scope once before checking the condition.
As I said before, there is no such thing in Python. However, you can emulate this behavior
using other methods. For example:

\begin{lstlisting}[language=python]
while True:
  something()
  if not condition:
    break
\end{lstlisting}

For-loop functions iterate over all elements of an iterable object. We can then for example
print all elements in a list using a for loop:

\begin{lstlisting}
my_list = [1, 2, 3]
for elt in my_list:
   print(elt)
\end{lstlisting}

You can basically give any kind of ``iterable'' objects to the for loop. We will see in the future
that you can even create your own kind of iterable objects.

\subsection{Exercise 1}
%% For this first exercise, you need to:

\begin{itemize}
\item Write the ``powerpuff\_role'' function which takes the name of a powerpuff girl as argument
  and returns the role of the powerpuff girl. For example, powerpuff\_role('Blossom') should return
  ``commander and the leader''. If the argument is not a powerpuff girl, it should return None.
\item Write the ``get\_roles'' function which takes a list of string as parameter and prints the powerpuff role
  of each of them. It should explicitely print if the given parameter is not a powerpuff girl.
\item Write the ``anonymize'' function, which takes a list of string as parameter and replace them with their index
  in the list. This function should not return a new list, but change the original one.
\end{itemize}

\subsection{Modules, packages and main}
\subsubsection{Modules}
To enable code sharing between different files, Python uses a concept called modules. A module
is nothing more than a Python file that you include in another file. For example, let's say
you declare a function in a file and want to use it in another file:

\begin{lstlisting}[language=python]
# Declaring a function in utils.py
# Oh ! did you see? It's our first comment ! :D

def noodle_house(thirsty):
   if thirsty:
      return 'Pho Thai'
   return 'Mapo Tofu'
\end{lstlisting}

We can use this function in our modules.py file:

\begin{lstlisting}[language=python]
import utils

print('Yesterday I was thirsty, so I ordered',
      utils.noodle_house(True))

print('But usually, I order', utils.noodle_house(False))
\end{lstlisting}

Which gives the following output:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 modules.py
  Yesterday I was thirsty, so I ordered Pho Thai
  But usually, I order Mapo Tofu
doudoush:~$
\end{lstlisting}

Here, we used the ``import'' keyword followed by the name of the file we want to import
without the extension. The result is a new variable named ``utils'', which contains all functions
and variables defined in the scope of the module. We can access these variables
using ``.'', as in ``utils.noodle\_house''. We can also choose to import only the function
that we want using the following syntax:

\begin{lstlisting}[language=python]
from utils import noodle_house

print('Yesterday I was thirsty, so I ordered',
      noodle_house(True))

print('But usually, I order', noodle_house(False))
\end{lstlisting}

However, when we do so, we can only access the function we imported. We cannot access anything
else about the ``utils'' module.

Two important things to note here. First, no matter how you choose to import the module,
(using ``import'' or ``from x import y'') Python will interpret the whole file. What does
it mean? Let's look at an example:

\begin{lstlisting}[language=python]
# Declaring a function in utils.py

print('Loading the utils module...')

def noodle_house(thirsty):
   if thirsty:
      return 'Pho Thai'
   return 'Mapo Tofu'

print('Done loading the module')
\end{lstlisting}

The Python binary has a command argument that allows to execute some Python code without
having to put it in a file. It's very useful when you just want to test a single line code.
This is what we will do here, as we just want to check the behavior of the ``import'' function.
To do so, we just need to use the ``-c'' option:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 -c 'import utils'
  Loading the utils module...
  Done loading the module
doudoush:~$ python3 -c 'from utils import noodle_house'
  Loading the utils module...
  Done loading the module
doudoush:~$
\end{lstlisting}

So keep in mind that if you load a module, the whole file is interpreted.

\vspace{5mm}

Second, the imported module is a variable like the others.
You may or may not know, but we can delete variables using the ``del'' keyword. We can then
unimport modules the same way:

\begin{lstlisting}[language=python]
import utils
del utils
utils.noodle_house()
\end{lstlisting}

This gives the following error:
\begin{lstlisting}[language=bash]
doudoush:~$ python3 del_module.py
  Traceback (most recent call last):
    File "del_modules.py", line 3, in <module>
      utils.noodle_house()
  NameError: name 'utils' is not defined
doudoush:~$
\end{lstlisting}

That's just an example illustrating that it's a variable like the others, but it's not really useful.
Let's look at another funny example. It's a variable right? Then, I can pass it to a function right?

Let's consider the following Python file:

\begin{lstlisting}[language=python]
# This is funny.py
def place_order(module):
  print('Hello! I would like', module.noodle_house(True))
\end{lstlisting}

Now, let's modify a bit the ``modules.py'' file:

\begin{lstlisting}[language=python]
import utils
import funny
funny.place_order(utils)
\end{lstlisting}

It works perfectly fine! The loaded module is a variable that is passed to the ``place\_order''
function of the ``funny'' module. We don't need to load the ``utils'' module in ``funny'' as
it's already given as an parameter of the function. Pretty cool right? But wait. This is super
useful! Because it means that if I need a function from a module in multiple other modules,
I can just give it as a parameter! I then don't need to import the module in all the other modules!
Right? Well, no. I mean yes, but Python is smarter than that. In a Python session, if you import
a module once, and try to import it again, it will not be reloaded. Let's update a bit the previous
files.

\begin{lstlisting}[language=python]
# This is funny.py
import utils

def place_order():
  print('Hello! I would like', utils.noodle_house(True))
\end{lstlisting}

And the ``modules.py'' file:

\begin{lstlisting}[language=python]
import utils
print('Loading funny')
import funny
funny.place_order()
\end{lstlisting}

And now, let's interpret the ``module.py'' file.

\begin{lstlisting}[language=bash]
doudoush:~$ python3 module.py
  Loading the utils module...
  Done loading the module
  Loading funny
  Hello! I would like Pho Thai
doudoush:~$
\end{lstlisting}

As you can see, the ``Loading the utils module'' statement got printed only once,
even though we imported the ``utils'' module both in ``module.py'' and ``funny.py''.
So don't worry, Python is smart.

\vspace{5mm}

Last thing about modules, is that there is actually a module to load modules (*mind explosion*).
Let's say we have two different implementation of the same function in two different modules.
We may want to load them dynamically (at runtime). Let's consider the following files:

\begin{lstlisting}[language=python]
# file noodle_house.py

def order():
  return 'Mapo Tofu'
\end{lstlisting}

\begin{lstlisting}[language=python]
# file panera.py

def order():
  return 'Steak and arugula sandwich'
\end{lstlisting}

We can dynamically load these modules this way:

\begin{lstlisting}[language=python]
# file order.py
from importlib import import_module

restaurant = import_module('noodle_house')
print('From Noodle House, I want', restaurant.order())

restaurant = import_module('panera')
print('From Panera, I want', restaurant.order())
\end{lstlisting}

Which thus gives:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 order.py
From Noodle House, I want Mapo Tofu
From Panera, I want Steak and arugula sandwich
doudoush:~$
\end{lstlisting}

Pretty cool right?

\subsubsection{Packages}

Python packages are nothing more than a suite of modules. In other words,
it's a directory with python files. Let's imagine we want to create a ``doudou'' package.
This package will host some utilities (bake cookies, explain python) from doudou split
into several modules (baking, coding). We will then have the following architecture:

\vspace{5mm}

\dirtree{%
.1 ./.
.1 main.py.
.1 doudou.
.2 baking.py.
.2 coding.py.
}

We could for example have the following code:

\begin{lstlisting}[language=python]
# File baking.py
def _bake(pastry):
  print(f'Baking {pastry}...')

def bake_cookies():
  _bake('cookies')

def bake_macarons():
  _bake('macarons')
\end{lstlisting}

\begin{lstlisting}[language=python]
# File coding.py
def explain_python():
  print('Python is interpreted')

def correct_exercise():
  print('Great! 20/20')
\end{lstlisting}

\begin{lstlisting}[language=python]
# File main.py
from doudou.baking import bake_cookies, bake_macarons
from doudou.coding import correct_exercise, explain_python

print(``I'm hungry!'')
bake_cookies()
bake_macarons()

print(``Teach me Sempai'')
explain_python()
correct_exercise()
\end{lstlisting}

We could of course also do:
\begin{lstlisting}[language=python]
# File main.py
import doudou

doudou.baking.bake_cookies()
doudou.baking.bake_macarons()

doudou.coding.explain_python()
doudou.coding.correct_exercise()
\end{lstlisting}

If we execute main, we get the expected behavior:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 main.py
  Baking cookies...
  Baking macarons...
  Python is interpreted
  Great! 20/20
doudoush:~$
\end{lstlisting}

So as you can see, we can now from the ``main.py'' file access modules of the ``doudou''
package and then functions of these modules. But this is not very clean. Indeed, we may
not be interested in the way the modules are designed, but only in the functions inside.
In this example, I don't care that ``bake\_cookies'' and ``explain\_python'' are in
different modules. They are both part of the ``doudou'' package and I want to be able to
access them the same way, as doudou skills. Python has an efficient way of organizing
packages. For this, we need to add a ``\_\_init\_\_.py'' file in the ``doudou'' directory,
as follow:

\vspace{5mm}

\dirtree{%
.1 ./.
.1 main.py.
.1 doudou.
.2 \_\_init\_\_.py.
.2 baking.py.
.2 coding.py.
}

\vspace{5mm}

In this file, we can specify the functions we want to expose as part of the package.
For example, you may have noticed that there is a ``\_bake'' function in the baking package.
Usually, when the name of a function starts with ``\_'', it means that it is private.
We thus don't want to expose it in our package. Our ``\_\_init\_\_.py'' file could then
look like this:

\begin{lstlisting}[language=python]
from .baking import bake_cookies, bake_macarons
from .coding import correct_exercise, explain_python
\end{lstlisting}

The ``main.py'' file could then be updated this way:

\begin{lstlisting}[language=python]
from doudou import bake_cookies, explain_python

bake_cookies()
explain_python()
\end{lstlisting}

Or also:
\begin{lstlisting}[language=python]
import doudou

doudou.bake_cookies()
doudou.explain_python()
\end{lstlisting}

Which would give the expected output:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 main.py
Baking cookies...
Python is interpreted
doudoush:~$
\end{lstlisting}

However, if we try to access the ``\_bake'' directly from the ``doudou'' package:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 -c 'from doudou import _bake'
    Traceback (most recent call last):
    File "<string>", line 1, in <module>
  ImportError: cannot import name '_bake' from 'doudou'
doudoush:~$
\end{lstlisting}

Note that our previous code would still work. We can still access the function
from the module, and not only from the package. That means that we can still access
the ``\_bake'' function from the module:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 -c 'from doudou.baking import _bake; _bake("marbre")'
Baking marbre...
doudoush:~$
\end{lstlisting}

Indeed, nothing is private in Python. Also note that when we import a function from
a module, the ``\_\_init\_\_.py'' will still be interpreted. For example, if we update
the init file this way:

\begin{lstlisting}[language=python]
print('Loading init')
from .baking import bake_cookies, bake_macarons
from .coding import correct_exercise, explain_python
print('Done loading init')
\end{lstlisting}

And add this line at the top of ``baking.py'':
\begin{lstlisting}[language=python]
print('Loading baking')
\end{lstlisting}


And try to import it these ways:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 -c 'from doudou import bake_cookies'
  Loading init
  Loading baking
  Done loading init
doudoush:~$ python3 -c 'from doudou.baking import bake_cookies'
  Loading init
  Loading baking
  Done loading init
doudoush:~$
\end{lstlisting}

So as you can see, the init file is always interpreted. But what if we try to import
a module that is not part of the init file? Let's remove the baking module from the
init file:

\begin{lstlisting}[language=python]
print('Loading init')
from .coding import correct_exercise, explain_python
print('Done loading init')
\end{lstlisting}

And now, let's import it again:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 -c 'from doudou.baking import bake_cookies'
  Loading init
  Done loading init
  Loading baking
doudoush:~$
\end{lstlisting}

The order has changed. This is the expected behavior. Indeed, as I mentioned, the
init file will always be loaded. So when we run ``from doudou.baking import'',
it will first read the ``doudou'' module and see if it imports something useful from
the module. Then, it will go into the ``baking'' module and load it.

% main

\subsection{Dealing with external resources}
\subsubsection{Parsing arguments}
\subsubsection{Files}
\subsubsection{The sys module}

\subsection{Exercise 2}
% dynamic load something given as argument
% Implement several restaurants as packages 

\subsection{Data structures}
\subsubsection{List}
\subsubsection{Tuple}
\subsubsection{Set}
\subsubsection{Dict}

\subsection{Arguments and named arguments}

\subsection{Project: myFind}
