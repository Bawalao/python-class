
\section{Basics}

Welcome to the first part of the Doudou Python tutorial!  This part
will cover all basic Python primitives including functions, variables,
how they are managed etc. Let's go!

\subsection{Variables}

Python is a (mostly) interpreted dynamically typed language. Why
mostly? Because it is possible to compile Python. We will get into
more details about it in the advanced section. Why dynamically typed?
Because in Python, you don't need to explicitly specify the type of a
variable, it will be deduced based on the value you are assigning the
variable to. Moreover, you can reassign the same variable with a
different type, because the type will dynamically change based on the
value you are assigning to it. Let's look at an example. In Python,
we can use the ``type'' keyword to evaluate the type of a variable.
Also, we will use the ``print'' built-in function, which takes an
``infinite'' number of arguments as input and displays them on the
standard output, separated by spaces.

\begin{lstlisting}[language=python]
  a = 5
  print(a, 'of type', type(a))
  a = 'hello'
  print(a, 'of type', type(a))
\end{lstlisting}

Now let's execute this code.

\begin{lstlisting}[language=bash]
  doudoush:~$ python3 variable.py
   5 of type <class 'int'>
   hello of type <class 'str'>
  doudoush:~$
\end{lstlisting}

While other languages (like C++) would have complained that you cannot assign
the value ``hello'' of type string to the variable ``a'' of type integer, Python
doesn't care and simply reassign the value and the type of the variable.

\vspace{5mm}
Also, remember that as the language is interpreted, you can execute some code before
an error happens. For example, if you forget to define a variable, the error will
be raised only when you try to use this variable/

\begin{lstlisting}[language=python]
  blossom = 'commander and the leader'
  bubbles = 'the joy and a laugher'

  print('Blossom', blossom)
  print('Bubbles', bubbles)
  print('Buttercup', buttercup)
\end{lstlisting}

Gives the output:

\begin{lstlisting}[language=bash]
  doudoush:~$ python3 variables.py
   Blossom commander and the leader
   Bubbles the joy and a laugher
   Traceback (most recent call last):
     File "variables.py", line 12, in <module>
       print('Buttercup', buttercup)
   NameError: name 'buttercup' is not defined
  doudoush:~$
\end{lstlisting}

Other languages like C++ would have complained that the variable ``buttercup''
did not exist before printing the two other variables.

\subsection{Combining variables}

Another cool aspect of the Python language is the way you can combine variables.
For example, as with many other languages, you can combine high level types with
lower level types. For example, if you do the sum of an integer and a float,
the result will be a variable of type float:

\begin{lstlisting}[language=python]
cactus = 4
cactus += 0.5

print(cactus, 'of type', type(cactus))
\end{lstlisting}

Outputs:

\begin{lstlisting}[language=bash]
  doudoush:~$ python3 variables.py
    4.5 of type <class 'float'>
  doudoush:~$
\end{lstlisting}

Pretty obvious yes. But what happens if we try to add an integer to a string?

\begin{lstlisting}[language=python]
  cactus = 3
  cactus += ' is your lucky number'
\end{lstlisting}

\begin{lstlisting}[language=bash]
  doudoush:~$ python3 variables.py
    Traceback (most recent call last):
    File "variables.py", line 2, in <module>
      cactus += ' is your lucky number'
      TypeError: unsupported operand type(s) for +=: 'int' and 'str'
  doudoush:~$
\end{lstlisting}

This is because it tries to call the ``+'' operator from the ``int'' primitive type.
However, this operator is not defined for variables of type ``str''. We will get
into more details in the following section about functions.

\vspace{5mm}

You may thus wonder how can we combine strings and integers? Well, there are
several ways. The quick and dirty way is to explicitly cast the variable to
the target type. Of course, it does not make sense to try to cast a string to
an integer, as there is no obvious semantic to this operation. So we will do
the other way around, and try to convert 3 into ``3``. The cast operators are simply
the type of the variable used as a function:

\begin{lstlisting}[language=python]
  cactus = 3
  cactus = str(cactus) + ' is your lucky number'
  print(cactus)
\end{lstlisting}

Which works as expected:

\begin{lstlisting}[language=bash]
  doudoush:~$ python3 variables.py
    3 is your lucky number
  doudoush:~$
\end{lstlisting}

However, for string there is a much better way of doing this: string formatting!
There are three different ways of doing string formatting: the old way, the modern way
and the very modern way. The old way is a C-style formatting:

\begin{lstlisting}[language=python]
  cactus = 3
  my_str = '%d is your lucky number' % cactus
\end{lstlisting}

You can also define the way you want the number will be displayed. For example, if you
want to add zeros before the number, you can write ``\%03d'' to specify that
the number should have 3 digits:

\begin{lstlisting}[language=python]
  my_str = '%03d is your lucky number' % 3
  print(my_str)
  my_str = '%03d is our lucky number' % 25
  print(my_str)
\end{lstlisting}

Will output:
\begin{lstlisting}[language=bash]
  doudoush:~$ python3 variables.py
    003 is your lucky number
    025 is our lucky number
  doudoush:~$
\end{lstlisting}

The number got padded with two zeros, and the number twenty five with only one zero,
as it's already a two-digits number.

\vspace{5mm}

Here, the ``\%d'' is the syntax to substitute an entry to an integer. For floating
number, we would use ``\%f'', for string ``\%s''. We can also use this syntax to
substitute multiple variables:

\begin{lstlisting}[language=python]
  cactus = 3
  kind = 'lucky number'
  my_str = '%d is your %s' % (cactus, kind)
\end{lstlisting}


The modern way uses the ``format'' keyword. The main advantage of this method is
that you do not need to specify the type of the variable you want to combine.
We can then write the previous code like this:

\begin{lstlisting}[language=python]
  cactus = 3
  kind = 'lucky number'
  my_str = '{} is your {}'.format(cactus, kind)
\end{lstlisting}

Here, we just need to add ``{}'' every time we need to insert a variable. We them
substitute all of these variables as arguments to the format function. We can also
do zeros padding this way:

\begin{lstlisting}[language=python]
  cactus = 3
  kind = 'lucky number'
  my_str = '{:03} is your {}'.format(cactus, kind)
\end{lstlisting}

Finally, the very modern (Python >= 3.6) way does not require the use of the format
function, and uses a new language syntax:

\begin{lstlisting}[language=python]
  cactus = 3
  kind = 'lucky number'
  my_str = f'{cactus:03} is your {kind}'
  print(my_str)
\end{lstlisting}

Here, we just need to add the ``f'' character before the string to specify that
this string needs formatting, and we then just add the name of the variable directly
where we want them to appear. This of course gives the same output:

\begin{lstlisting}[language=bash]
  doudoush:~$ python3 variables.py
    003 is your lucky number
  doudoush:~$
\end{lstlisting}

\subsection{Functions and argument forwarding}
Before going into the important part of this section, let's just take a quick look
at functions in general in Python. First thing first, we create functions using
the ``def'' keyword, as follow:

\begin{lstlisting}[language=python]
  def say_hello():
    print('Hello!')
\end{lstlisting}

Note that we indented the code after defining our function. When we increment the
indentation, we create a ``scope''. A scope is kind of a virtual environment where variables live.
When you create a variable within a scope, it only lives in this scope. So if you create
a variable in a function, it will not be available outside of the function. Same happens with
other languages such as C++. However, in C++, scopes are delimited by ``{}'', while in Python they
are delimited by indent levels.

\vspace{5mm}

You can use either tabs or spaces for the indentation. However, in a file, as long as you started
using something (say spaces) you cannot use something else later on. I recommend using only spaces,
as editors tend to show tabulations differently (sometimes 2 spaces, sometimes 4).

\vspace{5mm}

Another important thing to know about functions is that functions are also variables. Meaning this
code works perfectly:

\begin{lstlisting}[language=python]
  def say_hello():
    print('Hello!')
  new_func = say_hello
  new_func()
\end{lstlisting}

Last important thing you need to know is that there is no such thing as void functions in Python.
Meaning that all functions in Python return something. I know what you're thinking: ``What? How come?
You didn't return anything here!''. That's true, but Python did. By default, if you do not explicitely
return something, Python returns ``None''. None is a special ``variable'' in Python,
like ``NULL/nullptr'' in C/C++. Like all other variables, it has a type, which is ``NoneType''.
So if we do:

\begin{lstlisting}[language=python]
  def say_hello():
    print('Hello!')
  new_func = say_hello
  result = new_func()
  print(type(result))
\end{lstlisting}

We get:
\begin{lstlisting}[language=bash]
  doudoush:~$ python3 func.py
    Hello!
    <class 'NoneType'>
  doudoush:~$
\end{lstlisting}

That's pretty much all you need to know about functions for now.

\subsubsection{Argument forwarding}

This is the most important part of this section. In this subsection, I will
try to answer as clearly as possible the question ``how the hell are variables
passed in Python?''. The quick answer is ``by assignment''. The useless (but accurate)
answer is ``by un-rebindable reference''. Is that clear?

\vspace{5mm}

No, of course it's not clear. Firstly, you need to know that in
Python, there are mutable and immutable types. Most primitive types
are immutable. If you want to change their value, you must create a
new object. For example, int, float, string, tuples are immutable. You
cannot do:

\begin{lstlisting}[language=python]
  cactus = 'hallo'
  cactus[1] = 'e'
\end{lstlisting}

You will get the following error message:

\begin{lstlisting}[language=bash]
  doudoush:~$ python3 variables.py
    Traceback (most recent call last):
    File "forwarding.py", line 2, in <module>
      a[1] = 'e'
      TypeError: 'str' object does not support item assignment
  doudoush:~$
\end{lstlisting}

Lists however are mutable, you can change elements inside a list
(more on that in the data structure section).

\vspace{5mm}

There are two different types of operation: in-place and not in-place.
In place means that the operation is applied directly on the variable, while the later
returns a new variable. You cannot do in-place operations on immutable variables,
which makes sense as they cannot be modified directly.

\vspace{5mm}

Last point before answering the real question, binding the variables. If you don't
remember, binding a variable is the action of linking a variable to its actual value.
Let's first take a look at a quick example:

\begin{lstlisting}[language=python]
  a = 5
  b = a
  b += 1
  print('a is', a)
  print('b is', b)
\end{lstlisting}

Which gives:

\begin{lstlisting}[language=bash]
  doudoush:~$ python3 forwarding.py
    a is 5
    b is 6
  doudoush:~$
\end{lstlisting}

Here, ``b'' is a reference on a NEW object with value 5. Thus, changing ``b'' DOES NOT have any impact
on the variable ``a''. You can imagine that when we do ``b = a'', a is actually replaced by its value,
meaning that this code is exactly the same:

\begin{lstlisting}[language=python]
  a = 5
  b = 5
  b += 1
  print('a is', a)
  print('b is', b)
\end{lstlisting}

Basically, when you create a variable, you are allocating some memory and assigning a reference
to this memory location. You cannot change what this reference is pointing to.

\vspace{5mm}
Now, let's get back to the real problem: how are arguments passed in functions. The answer is by reference.
BUT, without forgetting the rules aforementioned. Let's take a look at a quick example:

\begin{lstlisting}[language=python]
  def my_function(my_int, my_list):
    my_list[2] = 5
    my_int += 4
    print('In function', my_int)

  my_int = 1
  my_list = [0, 1, 2, 3, 4]
  my_function(my_int, my_list)
  print('my_int', my_int)
  print('my_list', my_list)
\end{lstlisting}

Gives:

\begin{lstlisting}[language=bash]
  doudoush:~$ python3 forwarding.py
    In function 5
    my_int 1
    my_list [0, 1, 5, 3, 4]
  doudoush:~$
\end{lstlisting}

``my\_int'' is immutable. So whatever you do, you cannot change it. ``my\_list'' is mutable,
so we can change the elements inside the list in the function. But what if we tried to
reassign ``my\_list?'' Let's see:

\begin{lstlisting}[language=python]
  def my_function(my_int, my_list):
    my_list[2] = 5
    my_int += 4
    print('In function', my_int)
    my_list = [3, 6, 25]
    print('In function', my_list)

  my_int = 1
  my_list = [0, 1, 2, 3, 4]
  my_function(my_int, my_list)
  print('my_int', my_int)
  print('my_list', my_list)
\end{lstlisting}

Which gives:

\begin{lstlisting}[language=bash]
  doudoush:~$ python3 forwarding.py
    In function 5
    In function [3, 6, 25]
    my_int 1
    my_list [0, 1, 5, 3, 4]
  doudoush:~$
\end{lstlisting}

So what happened here? Remember what I said? You CANNOT REBIND A REFERENCE.
So basically, you can modify a mutable object, but you cannot reassign it.
When you do ``my\_list += [3, 6, 25]'' you are creating a new local object called ``my\_list''
which ONLY exists in the scope of this function. When we exit the function, the local ``my\_list''
no longer exists, and we are back with the good old ``my\_list'', which, as a nice mutable
object, got modified in the function.

\vspace{5mm}

Soooo, to recap:

\begin{itemize}
\item When you use the ``='' operator, you are creating a new object.
\item When you pass an object to a function, it is passed by reference.
\item If the object is mutable, you can modify it (but not reassign it)
\item If it is immutable, you cannot change it at all.
\end{itemize}

\subsection{Conditions and loop}

\subsection{Exercises}

\subsection{Modules and Packages}

\subsection{Dealing with external resources}
\subsubsection{Parsing arguments}
\subsubsection{Files}
\subsubsection{The sys module}

\subsection{Exercises}

\subsection{Data structures}
\subsubsection{List}
\subsubsection{Tuple}
\subsubsection{Set}
\subsubsection{Dict}

\subsection{Arguments and named arguments}

\subsection{Project: myFind}
