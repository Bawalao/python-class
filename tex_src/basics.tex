
\section{Basics}

Welcome to the first part of the Doudou Python tutorial!  This part
will cover all basic Python primitives including functions, variables,
how they are managed etc. Let's go!

\subsection{Variables}

Python is a (mostly) interpreted dynamically typed language. Why
mostly? Because it is possible to compile Python. We will get into
more details about it in the advanced section. Why dynamically typed?
Because in Python, you don't need to explicitly specify the type of a
variable, it will be deduced based on the value you are assigning the
variable to. Moreover, you can reassign the same variable with a
different type, because the type will dynamically change based on the
value you are assigning to it. Let's look at an example. In Python,
we can use the ``type'' keyword to evaluate the type of a variable.
Also, we will use the ``print'' built-in function, which takes an
``infinite'' number of arguments as input and displays them on the
standard output, separated by spaces.

\begin{lstlisting}[language=python]
a = 5
print(a, 'of type', type(a))
a = 'hello'
print(a, 'of type', type(a))
\end{lstlisting}

Now let's execute this code.

\begin{lstlisting}[language=bash]
doudoush:~$ python3 variable.py
 5 of type <class 'int'>
 hello of type <class 'str'>
doudoush:~$
\end{lstlisting}

While other languages (like C++) would have complained that you cannot assign
the value ``hello'' of type string to the variable ``a'' of type integer, Python
doesn't care and simply reassign the value and the type of the variable.

\vspace{5mm}
Also, remember that as the language is interpreted, you can execute some code before
an error happens. For example, if you forget to define a variable, the error will
be raised only when you try to use this variable/

\begin{lstlisting}[language=python]
blossom = 'commander and the leader'
bubbles = 'the joy and a laugher'

print('Blossom', blossom)
print('Bubbles', bubbles)
print('Buttercup', buttercup)
\end{lstlisting}

Gives the output:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 variables.py
 Blossom commander and the leader
 Bubbles the joy and a laugher
 Traceback (most recent call last):
   File "variables.py", line 12, in <module>
     print('Buttercup', buttercup)
 NameError: name 'buttercup' is not defined
doudoush:~$
\end{lstlisting}

Other languages like C++ would have complained that the variable ``buttercup''
did not exist before printing the two other variables.

\subsection{Combining variables}

Another cool aspect of the Python language is the way you can combine variables.
For example, as with many other languages, you can combine high level types with
lower level types. For example, if you do the sum of an integer and a float,
the result will be a variable of type float:

\begin{lstlisting}[language=python]
cactus = 4
cactus += 0.5

print(cactus, 'of type', type(cactus))
\end{lstlisting}

Outputs:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 variables.py
  4.5 of type <class 'float'>
doudoush:~$
\end{lstlisting}

Pretty obvious yes. But what happens if we try to add an integer to a string?

\begin{lstlisting}[language=python]
cactus = 3
cactus += ' is your lucky number'
\end{lstlisting}

\begin{lstlisting}[language=bash]
doudoush:~$ python3 variables.py
  Traceback (most recent call last):
  File "variables.py", line 2, in <module>
    cactus += ' is your lucky number'
    TypeError: unsupported operand type(s) for +=: 'int' and 'str'
doudoush:~$
\end{lstlisting}

This is because it tries to call the ``+'' operator from the ``int'' primitive type.
However, this operator is not defined for variables of type ``str''. We will get
into more details in the following section about functions.

\vspace{5mm}

You may thus wonder how can we combine strings and integers? Well, there are
several ways. The quick and dirty way is to explicitly cast the variable to
the target type. Of course, it does not make sense to try to cast a string to
an integer, as there is no obvious semantic to this operation. So we will do
the other way around, and try to convert 3 into ``3``. The cast operators are simply
the type of the variable used as a function:

\begin{lstlisting}[language=python]
cactus = 3
cactus = str(cactus) + ' is your lucky number'
print(cactus)
\end{lstlisting}

Which works as expected:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 variables.py
  3 is your lucky number
doudoush:~$
\end{lstlisting}

However, for string there is a much better way of doing this: string formatting!
There are three different ways of doing string formatting: the old way, the modern way
and the very modern way. The old way is a C-style formatting:

\begin{lstlisting}[language=python]
cactus = 3
my_str = '%d is your lucky number' % cactus
\end{lstlisting}

You can also define the way you want the number will be displayed. For example, if you
want to add zeros before the number, you can write ``\%03d'' to specify that
the number should have 3 digits:

\begin{lstlisting}[language=python]
my_str = '%03d is your lucky number' % 3
print(my_str)
my_str = '%03d is our lucky number' % 25
print(my_str)
\end{lstlisting}

Will output:
\begin{lstlisting}[language=bash]
doudoush:~$ python3 variables.py
  003 is your lucky number
  025 is our lucky number
doudoush:~$
\end{lstlisting}

The number got padded with two zeros, and the number twenty five with only one zero,
as it's already a two-digits number.

\vspace{5mm}

Here, the ``\%d'' is the syntax to substitute an entry to an integer. For floating
number, we would use ``\%f'', for string ``\%s''. We can also use this syntax to
substitute multiple variables:

\begin{lstlisting}[language=python]
cactus = 3
kind = 'lucky number'
my_str = '%d is your %s' % (cactus, kind)
\end{lstlisting}


The modern way uses the ``format'' keyword. The main advantage of this method is
that you do not need to specify the type of the variable you want to combine.
We can then write the previous code like this:

\begin{lstlisting}[language=python]
cactus = 3
kind = 'lucky number'
my_str = '{} is your {}'.format(cactus, kind)
\end{lstlisting}

Here, we just need to add ``\{\}'' every time we need to insert a variable. We them
substitute all of these variables as arguments to the format function. We can also
do zeros padding this way:

\begin{lstlisting}[language=python]
cactus = 3
kind = 'lucky number'
my_str = '{:03} is your {}'.format(cactus, kind)
\end{lstlisting}

Finally, the very modern (Python >= 3.6) way does not require the use of the format
function, and uses a new language syntax:

\begin{lstlisting}[language=python]
cactus = 3
kind = 'lucky number'
my_str = f'{cactus:03} is your {kind}'
print(my_str)
\end{lstlisting}

Here, we just need to add the ``f'' character before the string to specify that
this string needs formatting, and we then just add the name of the variable directly
where we want them to appear. This of course gives the same output:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 variables.py
  003 is your lucky number
doudoush:~$
\end{lstlisting}

\subsection{Functions and argument forwarding}
Before going into the important part of this section, let's just take a quick look
at functions in general in Python. First thing first, we create functions using
the ``def'' keyword, as follow:

\begin{lstlisting}[language=python]
def say_hello():
  print('Hello!')
\end{lstlisting}

Note that we indented the code after defining our function. When we increment the
indentation, we create a ``scope''. A scope is kind of a virtual environment where variables live.
When you create a variable within a scope, it only lives in this scope. So if you create
a variable in a function, it will not be available outside of the function. Same happens with
other languages such as C++. However, in C++, scopes are delimited by ``\{\}'', while in Python they
are delimited by indent levels.

\vspace{5mm}

You can use either tabs or spaces for the indentation. However, in a file, as long as you started
using something (say spaces) you cannot use something else later on. I recommend using only spaces,
as editors tend to show tabulations differently (sometimes 2 spaces, sometimes 4).

\vspace{5mm}

Another important thing to know about functions is that functions are also variables. Meaning this
code works perfectly:

\begin{lstlisting}[language=python]
def say_hello():
  print('Hello!')
new_func = say_hello
new_func()
\end{lstlisting}

Last important thing you need to know is that there is no such thing as void functions in Python.
Meaning that all functions in Python return something. I know what you're thinking: ``What? How come?
You didn't return anything here!''. That's true, but Python did. By default, if you do not explicitely
return something, Python returns ``None''. None is a special ``variable'' in Python,
like ``NULL/nullptr'' in C/C++. Like all other variables, it has a type, which is ``NoneType''.
So if we do:

\begin{lstlisting}[language=python]
def say_hello():
  print('Hello!')
new_func = say_hello
result = new_func()
print(type(result))
\end{lstlisting}

We get:
\begin{lstlisting}[language=bash]
doudoush:~$ python3 func.py
  Hello!
  <class 'NoneType'>
doudoush:~$
\end{lstlisting}

You can otherwise return a real result using the ``return'' keyword:

\begin{lstlisting}[language=python]
def say_hello():
  return 'Hello!'

result = say_hello()
print(result)
\end{lstlisting}

\begin{lstlisting}[language=bash]
doudoush:~$ python3 func.py
  Hello!
doudoush:~$
\end{lstlisting}

Also note that there is no static return type in a function, as the language is dynamically typed. You can
then do:

\begin{lstlisting}
def my_func(i):
  if i < 2:
    return True
  return 'cactus'
\end{lstlisting}

That's pretty much all you need to know about functions for now.

\subsubsection{Argument forwarding}

This is the most important part of this section. In this subsection, I will
try to answer as clearly as possible the question ``how the hell are variables
passed in Python?''. The quick answer is ``by assignment''. The useless (but accurate)
answer is ``by un-rebindable reference''. Is that clear?

\vspace{5mm}

No, of course it's not clear. Firstly, you need to know that in
Python, there are mutable and immutable types. Most primitive types
are immutable. If you want to change their value, you must create a
new object. For example, int, float, string, tuples are immutable. You
cannot do:

\begin{lstlisting}[language=python]
cactus = 'hallo'
cactus[1] = 'e'
\end{lstlisting}

You will get the following error message:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 variables.py
  Traceback (most recent call last):
  File "forwarding.py", line 2, in <module>
    a[1] = 'e'
    TypeError: 'str' object does not support item assignment
doudoush:~$
\end{lstlisting}

Lists however are mutable, you can change elements inside a list
(more on that in the data structure section).

\vspace{5mm}

There are two different types of operation: in-place and not in-place.
In place means that the operation is applied directly on the variable, while the later
returns a new variable. You cannot do in-place operations on immutable variables,
which makes sense as they cannot be modified directly.

\vspace{5mm}

Last point before answering the real question, binding the variables. If you don't
remember, binding a variable is the action of linking a variable to its actual value.
Let's first take a look at a quick example:

\begin{lstlisting}[language=python]
a = 5
b = a
b += 1
print('a is', a)
print('b is', b)
\end{lstlisting}

Which gives:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 forwarding.py
  a is 5
  b is 6
doudoush:~$
\end{lstlisting}

Here, ``b'' is a reference on a NEW object with value 5. Thus, changing ``b'' DOES NOT have any impact
on the variable ``a''. You can imagine that when we do ``b = a'', a is actually replaced by its value,
meaning that this code is exactly the same:

\begin{lstlisting}[language=python]
a = 5
b = 5
b += 1
print('a is', a)
print('b is', b)
\end{lstlisting}

Basically, when you create a variable, you are allocating some memory and assigning a reference
to this memory location. You cannot change what this reference is pointing to.

\vspace{5mm}
Now, let's get back to the real problem: how are arguments passed in functions. The answer is by reference.
BUT, without forgetting the rules aforementioned. Let's take a look at a quick example:

\begin{lstlisting}[language=python]
def my_function(my_int, my_list):
  my_list[2] = 5
  my_int += 4
  print('In function', my_int)

my_int = 1
my_list = [0, 1, 2, 3, 4]
my_function(my_int, my_list)
print('my_int', my_int)
print('my_list', my_list)
\end{lstlisting}

Gives:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 forwarding.py
  In function 5
  my_int 1
  my_list [0, 1, 5, 3, 4]
doudoush:~$
\end{lstlisting}

``my\_int'' is immutable. So whatever you do, you cannot change it. ``my\_list'' is mutable,
so we can change the elements inside the list in the function. But what if we tried to
reassign ``my\_list?'' Let's see:

\begin{lstlisting}[language=python]
def my_function(my_int, my_list):
  my_list[2] = 5
  my_int += 4
  print('In function', my_int)
  my_list = [3, 6, 25]
  print('In function', my_list)

my_int = 1
my_list = [0, 1, 2, 3, 4]
my_function(my_int, my_list)
print('my_int', my_int)
print('my_list', my_list)
\end{lstlisting}

Which gives:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 forwarding.py
  In function 5
  In function [3, 6, 25]
  my_int 1
  my_list [0, 1, 5, 3, 4]
doudoush:~$
\end{lstlisting}

So what happened here? Remember what I said? You CANNOT REBIND A REFERENCE.
So basically, you can modify a mutable object, but you cannot reassign it.
When you do ``my\_list += [3, 6, 25]'' you are creating a new local object called ``my\_list''
which ONLY exists in the scope of this function. When we exit the function, the local ``my\_list''
no longer exists, and we are back with the good old ``my\_list'', which, as a nice mutable
object, got modified in the function.

\vspace{5mm}

Soooo, to recap:

\begin{itemize}
\item When you use the ``='' operator, you are creating a new object.
\item When you pass an object to a function, it is passed by reference.
\item If the object is mutable, you can modify it (but not reassign it)
\item If it is immutable, you cannot change it at all.
\end{itemize}

\subsection{Conditions and loop}
I will go very quickly about this part because there is nothing special here.
As for the functions, conditions and loops live in scopes, defined with indent levels.
Conditions are defined with the ``if'' keyword, as follow:

\begin{lstlisting}[language=python]
def is_even(n):
  if n % 2 == 0:
    return True
  return False
\end{lstlisting}

You can also check multiple conditions this way:
\begin{lstlisting}[language=python]
  if something:
    blabla()
  elif something_else:
    blablabla()
  else:
    blibloblablu()
\end{lstlisting}


There are two types of loops in Python: While loops, and for loops. You can exit
these loops using the ``break'' keyword or go the next iteration using the ``continue''
keyword. The first kind of loop repeats a scope of instructions until a criterion is met.

For example:

\begin{lstlisting}
i = 0
while i < 10:
  i += 1
\end{lstlisting}

Here we are incrementing the value of ``i'' by 1 until it reaches 10. Unlike other
languages like C++, there is no ``do-while'' instructions. So here, the condition has
to be true for the code to be executed even the first time.

Let's take a look at the following C++ code:

\begin{lstlisting}[language=C++]
int i = 20;
do
{
  i += 1;
} while(i < 10);
std::cout << i << std::endl;
\end{lstlisting}

If we compile and execute this code inside a main, it will display 21. This is because
the ``do-while'' loop will always execute the scope once before checking the condition.
As I said before, there is no such thing in Python. However, you can emulate this behavior
using other methods. For example:

\begin{lstlisting}[language=python]
while True:
  something()
  if not condition:
    break
\end{lstlisting}

For-loop functions iterate over all elements of an iterable object. We can then for example
print all elements in a list using a for loop:

\begin{lstlisting}
my_list = [1, 2, 3]
for elt in my_list:
   print(elt)
\end{lstlisting}

You can basically give any kind of ``iterable'' objects to the for loop. We will see in the future
that you can even create your own kind of iterable objects.

\subsection{Exercise 1}
%% For this first exercise, you need to:

\begin{itemize}
\item Write the ``powerpuff\_role'' function which takes the name of a powerpuff girl as argument
  and returns the role of the powerpuff girl. For example, powerpuff\_role('Blossom') should return
  ``commander and the leader''. If the argument is not a powerpuff girl, it should return None.
\item Write the ``get\_roles'' function which takes a list of string as parameter and prints the powerpuff role
  of each of them. It should explicitely print if the given parameter is not a powerpuff girl.
\item Write the ``anonymize'' function, which takes a list of string as parameter and replace them with their index
  in the list. This function should not return a new list, but change the original one.
\end{itemize}

\subsection{Modules, packages and main}
\subsubsection{Modules}
To enable code sharing between different files, Python uses a concept called modules. A module
is nothing more than a Python file that you include in another file. For example, let's say
you declare a function in a file and want to use it in another file:

\begin{lstlisting}[language=python]
# Declaring a function in utils.py
# Oh ! did you see? It's our first comment ! :D

def noodle_house(thirsty):
   if thirsty:
      return 'Pho Thai'
   return 'Mapo Tofu'
\end{lstlisting}

We can use this function in our modules.py file:

\begin{lstlisting}[language=python]
import utils

print('Yesterday I was thirsty, so I ordered',
      utils.noodle_house(True))

print('But usually, I order', utils.noodle_house(False))
\end{lstlisting}

Which gives the following output:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 modules.py
  Yesterday I was thirsty, so I ordered Pho Thai
  But usually, I order Mapo Tofu
doudoush:~$
\end{lstlisting}

Here, we used the ``import'' keyword followed by the name of the file we want to import
without the extension. The result is a new variable named ``utils'', which contains all functions
and variables defined in the scope of the module. We can access these variables
using ``.'', as in ``utils.noodle\_house''. We can also choose to import only the function
that we want using the following syntax:

\begin{lstlisting}[language=python]
from utils import noodle_house

print('Yesterday I was thirsty, so I ordered',
      noodle_house(True))

print('But usually, I order', noodle_house(False))
\end{lstlisting}

However, when we do so, we can only access the function we imported. We cannot access anything
else about the ``utils'' module.

Two important things to note here. First, no matter how you choose to import the module,
(using ``import'' or ``from x import y'') Python will interpret the whole file. What does
it mean? Let's look at an example:

\begin{lstlisting}[language=python]
# Declaring a function in utils.py

print('Loading the utils module...')

def noodle_house(thirsty):
   if thirsty:
      return 'Pho Thai'
   return 'Mapo Tofu'

print('Done loading the module')
\end{lstlisting}

The Python binary has a command argument that allows to execute some Python code without
having to put it in a file. It's very useful when you just want to test a single line code.
This is what we will do here, as we just want to check the behavior of the ``import'' function.
To do so, we just need to use the ``-c'' option:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 -c 'import utils'
  Loading the utils module...
  Done loading the module
doudoush:~$ python3 -c 'from utils import noodle_house'
  Loading the utils module...
  Done loading the module
doudoush:~$
\end{lstlisting}

So keep in mind that if you load a module, the whole file is interpreted.

\vspace{5mm}

Second, the imported module is a variable like the others.
You may or may not know, but we can delete variables using the ``del'' keyword. We can then
unimport modules the same way:

\begin{lstlisting}[language=python]
import utils
del utils
utils.noodle_house()
\end{lstlisting}

This gives the following error:
\begin{lstlisting}[language=bash]
doudoush:~$ python3 del_module.py
  Traceback (most recent call last):
    File "del_modules.py", line 3, in <module>
      utils.noodle_house()
  NameError: name 'utils' is not defined
doudoush:~$
\end{lstlisting}

That's just an example illustrating that it's a variable like the others, but it's not really useful.
Let's look at another funny example. It's a variable right? Then, I can pass it to a function right?

Let's consider the following Python file:

\begin{lstlisting}[language=python]
# This is funny.py
def place_order(module):
  print('Hello! I would like', module.noodle_house(True))
\end{lstlisting}

Now, let's modify a bit the ``modules.py'' file:

\begin{lstlisting}[language=python]
import utils
import funny
funny.place_order(utils)
\end{lstlisting}

It works perfectly fine! The loaded module is a variable that is passed to the ``place\_order''
function of the ``funny'' module. We don't need to load the ``utils'' module in ``funny'' as
it's already given as an parameter of the function. Pretty cool right? But wait. This is super
useful! Because it means that if I need a function from a module in multiple other modules,
I can just give it as a parameter! I then don't need to import the module in all the other modules!
Right? Well, no. I mean yes, but Python is smarter than that. In a Python session, if you import
a module once, and try to import it again, it will not be reloaded. Let's update a bit the previous
files.

\begin{lstlisting}[language=python]
# This is funny.py
import utils

def place_order():
  print('Hello! I would like', utils.noodle_house(True))
\end{lstlisting}

And the ``modules.py'' file:

\begin{lstlisting}[language=python]
import utils
print('Loading funny')
import funny
funny.place_order()
\end{lstlisting}

And now, let's interpret the ``module.py'' file.

\begin{lstlisting}[language=bash]
doudoush:~$ python3 module.py
  Loading the utils module...
  Done loading the module
  Loading funny
  Hello! I would like Pho Thai
doudoush:~$
\end{lstlisting}

As you can see, the ``Loading the utils module'' statement got printed only once,
even though we imported the ``utils'' module both in ``module.py'' and ``funny.py''.
So don't worry, Python is smart.

\vspace{5mm}

Last thing about modules, is that there is actually a module to load modules (*mind explosion*).
Let's say we have two different implementation of the same function in two different modules.
We may want to load them dynamically (at runtime). Let's consider the following files:

\begin{lstlisting}[language=python]
# file noodle_house.py

def order():
  return 'Mapo Tofu'
\end{lstlisting}

\begin{lstlisting}[language=python]
# file panera.py

def order():
  return 'Steak and arugula sandwich'
\end{lstlisting}

We can dynamically load these modules this way:

\begin{lstlisting}[language=python]
# file order.py
from importlib import import_module

restaurant = import_module('noodle_house')
print('From Noodle House, I want', restaurant.order())

restaurant = import_module('panera')
print('From Panera, I want', restaurant.order())
\end{lstlisting}

Which thus gives:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 order.py
From Noodle House, I want Mapo Tofu
From Panera, I want Steak and arugula sandwich
doudoush:~$
\end{lstlisting}

Pretty cool right?

\subsubsection{Packages}

Python packages are nothing more than a suite of modules. In other words,
it's a directory with python files. Let's imagine we want to create a ``doudou'' package.
This package will host some utilities (bake cookies, explain python) from doudou split
into several modules (baking, coding). We will then have the following architecture:

\vspace{5mm}

\dirtree{%
.1 ./.
.1 main.py.
.1 doudou.
.2 baking.py.
.2 coding.py.
}

We could for example have the following code:

\begin{lstlisting}[language=python]
# File baking.py
def _bake(pastry):
  print(f'Baking {pastry}...')

def bake_cookies():
  _bake('cookies')

def bake_macarons():
  _bake('macarons')
\end{lstlisting}

\begin{lstlisting}[language=python]
# File coding.py
def explain_python():
  print('Python is interpreted')

def correct_exercise():
  print('Great! 20/20')
\end{lstlisting}

\begin{lstlisting}[language=python]
# File main.py
from doudou.baking import bake_cookies, bake_macarons
from doudou.coding import correct_exercise, explain_python

bake_cookies()
bake_macarons()

explain_python()
correct_exercise()
\end{lstlisting}

We could of course also do:
\begin{lstlisting}[language=python]
# File main.py
import doudou

doudou.baking.bake_cookies()
doudou.baking.bake_macarons()

doudou.coding.explain_python()
doudou.coding.correct_exercise()
\end{lstlisting}

If we execute main, we get the expected behavior:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 main.py
  Baking cookies...
  Baking macarons...
  Python is interpreted
  Great! 20/20
doudoush:~$
\end{lstlisting}

So as you can see, we can now from the ``main.py'' file access modules of the ``doudou''
package and then functions of these modules. But this is not very clean. Indeed, we may
not be interested in the way the modules are designed, but only in the functions inside.
In this example, I don't care that ``bake\_cookies'' and ``explain\_python'' are in
different modules. They are both part of the ``doudou'' package and I want to be able to
access them the same way, as doudou skills. Python has an efficient way of organizing
packages. For this, we need to add a ``\_\_init\_\_.py'' file in the ``doudou'' directory,
as follow:

\vspace{5mm}

\dirtree{%
.1 ./.
.1 main.py.
.1 doudou.
.2 \_\_init\_\_.py.
.2 baking.py.
.2 coding.py.
}

\vspace{5mm}

In this file, we can specify the functions we want to expose as part of the package.
For example, you may have noticed that there is a ``\_bake'' function in the baking package.
Usually, when the name of a function starts with ``\_'', it means that it is private.
We thus don't want to expose it in our package. Our ``\_\_init\_\_.py'' file could then
look like this:

\begin{lstlisting}[language=python]
from .baking import bake_cookies, bake_macarons
from .coding import correct_exercise, explain_python
\end{lstlisting}

The ``main.py'' file could then be updated this way:

\begin{lstlisting}[language=python]
from doudou import bake_cookies, explain_python

bake_cookies()
explain_python()
\end{lstlisting}

Or also:
\begin{lstlisting}[language=python]
import doudou

doudou.bake_cookies()
doudou.explain_python()
\end{lstlisting}

Which would give the expected output:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 main.py
Baking cookies...
Python is interpreted
doudoush:~$
\end{lstlisting}

However, if we try to access the ``\_bake'' directly from the ``doudou'' package:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 -c 'from doudou import _bake'
    Traceback (most recent call last):
    File "<string>", line 1, in <module>
  ImportError: cannot import name '_bake' from 'doudou'
doudoush:~$
\end{lstlisting}

Note that our previous code would still work. We can still access the function
from the module, and not only from the package. That means that we can still access
the ``\_bake'' function from the module:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 -c 'from doudou.baking import _bake; _bake("marbre")'
Baking marbre...
doudoush:~$
\end{lstlisting}

Indeed, nothing is private in Python. Also note that when we import a function from
a module, the ``\_\_init\_\_.py'' will still be interpreted. For example, if we update
the init file this way:

\begin{lstlisting}[language=python]
print('Loading init')
from .baking import bake_cookies, bake_macarons
from .coding import correct_exercise, explain_python
print('Done loading init')
\end{lstlisting}

And add this line at the top of ``baking.py'':
\begin{lstlisting}[language=python]
print('Loading baking')
\end{lstlisting}


And try to import it these ways:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 -c 'from doudou import bake_cookies'
  Loading init
  Loading baking
  Done loading init
doudoush:~$ python3 -c 'from doudou.baking import bake_cookies'
  Loading init
  Loading baking
  Done loading init
doudoush:~$
\end{lstlisting}

So as you can see, the init file is always interpreted. But what if we try to import
a module that is not part of the init file? Let's remove the baking module from the
init file:

\begin{lstlisting}[language=python]
print('Loading init')
from .coding import correct_exercise, explain_python
print('Done loading init')
\end{lstlisting}

And now, let's import it again:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 -c 'from doudou.baking import bake_cookies'
  Loading init
  Done loading init
  Loading baking
doudoush:~$
\end{lstlisting}

The order has changed. This is the expected behavior. Indeed, as I mentioned, the
init file will always be loaded. So when we run ``from doudou.baking import'',
it will first read the ``doudou'' module and see if it imports something useful from
the module. Then, it will go into the ``baking'' module and load it.

\subsubsection{Main}

As I mentioned, as long as you import a module, the whole file is interpreted.
This is not always the expected behavior. Let me give you an example. Let's say
we have a wonderful module called ``song'' which defines some song and sing
a different song with regards to today's date. Such a module could look like this:

\begin{lstlisting}[language=python]
import datetime

def powerpuff_song():
  print('Blossom! Commander and the leader')
  print('Bubbles! She is the joy and a laugher')
  print('Buttercup! She is the taughest fighter')
  print('Powerpuff save the day...')
  print('tou tou touuuu')

def posca_song():
  print('POSCA POSCAAAA')
  print('tou toudou tou tou tou touuu')
  print('tou toudou tou tou tou touuu')

current_day = datetime.now().day
if current_day % 2 == 0:
  powerpuff_song()
else:
  posca_song()
\end{lstlisting}

I know, it's a great module. But we are doing great things here right? So let's run it.

\begin{lstlisting}[language=bash]
doudoush:~$ python3 song.py
  POSCA POSCAAAA
  tou toudou tou tou tou touuu
  tou toudou tou tou tou touuu
doudoush:~$
\end{lstlisting}

Oh yeah I love that song. Today is the 29th so that's the one that got picked.
Ok, our module is great and we love it. We love it so much that we want to use these
songs in our wonderful jukebox module:

\begin{lstlisting}[language=python]
from song import powerpuff_song, posca_song

def jukebox(track):
    if track == 1:
        powerpuff_song()
    elif track == 2:
        posca_song()
    else:
        print('We only have two songs for now !')

print('Running the jukebox!')
jukebox(1)
\end{lstlisting}

Great! Let's run it!

\begin{lstlisting}[language=bash]
doudoush:~$ python3 jukebox.py
  POSCA POSCAAAA
  tou toudou tou tou tou touuu
  tou toudou tou tou tou touuu
  Running the jukebox!
  Blossom! Commander and the leader
  Bubbles! She is the joy and a laugher
  Buttercup! She is the taughest fighter
  Powerpuff save the day...
  tou tou touuuu
doudoush:~$
\end{lstlisting}

And that's not what we wanted. The problem is that when we imported the songs line 1 of
``jukebox.py'', the whole file got interpreted. So basically, it's like we did ``python3 song.py''
before executing the jukebox code. So, what do we do? I don't want to rewrite the songs. But I
still want the previous behavior when I call ``python3 song.py''. Python has a way of checking
if we are actually importing a module or running it. This information is store in the
``\_\_name\_\_' variable. Let's write a dummy file called ``dummy.py'':

\begin{lstlisting}[language=python]
print('name is', __name__)
\end{lstlisting}

And now, let's run it, and then import it:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 dummy.py
  name is __main__
doudoush:~$ python3 -c 'import dummy'
  name is dummy
doudoush:~$
\end{lstlisting}

As you can see, when we call Python on the module, the name is ``\_\_main\_\_',
but when we just import it, the name is ``dummy'', the name of the module. We can
then simply change the ``song.py'' file like this:

\begin{lstlisting}[language=python]
import datetime

def powerpuff_song():
  print('Blossom! Commander and the leader')
  print('Bubbles! She is the joy and a laugher')
  print('Buttercup! She is the taughest fighter')
  print('Powerpuff save the day...')
  print('tou tou touuuu')

def posca_song():
  print('POSCA POSCAAAA')
  print('tou toudou tou tou tou touuu')
  print('tou toudou tou tou tou touuu')

if __name__ == '__main__':
  current_day = datetime.now().day
  if current_day % 2 == 0:
    powerpuff_song()
  else:
    posca_song()
\end{lstlisting}

So now we have the expected behavior:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 song.py
  POSCA POSCAAAA
  tou toudou tou tou tou touuu
  tou toudou tou tou tou touuu
doudoush:~$ python3 jukebox.py
  Running the jukebox!
  Blossom! Commander and the leader
  Bubbles! She is the joy and a laugher
  Buttercup! She is the taughest fighter
  Powerpuff save the day...
  tou tou touuuu
doudoush:~$
\end{lstlisting}

\subsection{Dealing with external resources}
\subsubsection{Useful system modules}

\paragraph{The ``os'' module}
As you may know, Python is a cross platform language. That means that it
is meant to run on different platform without changing anything on the code.
So basically all the Python code we've written until now will run the same way
on Windows, Linux or MacOS. For what we've done so far, it's quite easy as we
didn't use any external resources. As soon as we need to access things outside
the language environment, it gets more difficult to be cross platform. This is
where the ``os'' module comes handy. It contains all the platform-specific utilities.
Or to be more precise, it contains generic implementations of platform-specific
functions.

\vspace{5mm}

That may not be obviously useful, but let's take a look at a very simple example:
paths. Windows and UNIX systems do not handle paths the same way. For example:

\begin{lstlisting}[language=python]
windows_path = 'one\two\three\four'
unix_path = 'one/two/three/four'
\end{lstlisting}

Of course, as a cross platform language by design, the ``os'' module brings
a way to get the name of the current operating system, through ``os.name''. This
variable contains ``posix'' for UNIX systems and ``nt'' for Windows (note that
we can get more precise OS information with other modules). So we could check the OS
and change the values of the path accordingly. However, it would be really
cumbersome to write two version of our paths. The ``os'' module
provides a useful function in the ``path'' module called ``join''. This function
takes an ``infinite'' number of arguments, and recreates a path using the correct
path separator w.r.t the system we are running it on:

\begin{lstlisting}[language=python]
import os
my_path = os.path.join('one', 'two', 'three', 'four')
print(my_path)
\end{lstlisting}

Now let's execute it on Windows (powershell) and MacOS (doudoush):

\begin{lstlisting}[language=bash]
PS D:\> python3.exe os_module.py
  one\two\three\four
PS D:\>
\end{lstlisting}

\begin{lstlisting}[language=bash]
doudoush:~$ python3 os_module.py
  one/two/three/four
doudoush:~$
\end{lstlisting}

The ``path'' module within the ``os'' module has a lot of other useful functions for
manipulating path. For example, ``os.path.basename'' gives the last element of a path
(in the previous example ``four''). You can also check if a file exists using ``/.os./.path./.exists''.


\vspace{5mm}

Another important difference between these two systems are endlines. On UNIX systems,
new lines are represented with the ``\textbackslash n'' character, while
Windows uses ``\textbackslash r\textbackslash n''.
The ``os'' module has a variable called ``linesep'' to represent this. So for example,
if you want to replace all new lines in a string by spaces:

\begin{lstlisting}[language=python]
# UNIX specific
my_str = my_str.replace('\n', ' ')

# Windows specific
my_str = my_str.replace('\r\n', ' ')

# Cross-platform
import os
my_str = my_str.replace(os.linesep, ' ')
\end{lstlisting}

\vspace{5mm}

The ``os'' module also brings a lot of useful function for manipulating files
and directories, environment variables, working directory:

\begin{itemize}
\item ``os.makedirs'' creates a path. It is the equivalent to ``mkdir -p''.
  It raises an exception if the directory already exists, unless you call it
  with ``exist\_ok=True''
\item ``os.listdir'' lists all files and directories of a given directory.
  Be careful, this function returns elements IN ARBITRARY ORDER. Remember
  to sort the output list if you need.
\item ``os.chroot'' changes the root directory of the current process
\item ``os.environ'' is a map that contains all environment variables.
\item ``os.system'' the most dangerous one. It executes a given command in a sub-shell.
  For example ``os.system('echo doudou')'' will print ``doudou''. Be very careful
  when using this function. Remember that with great power comes great responsibility.
\end{itemize}

\paragraph{The ``sys'' module}

This module provides an interface to the command line interpreter. You can
for example access the command line arguments, the stdin, stdout or stderr
file descriptors, the ``PATH'' environment variable...

\vspace{5mm}

Let's take a closer look to the one you are the most likely to need: ``sys.argv''.
This variable returns a list with all the arguments given to Python.
Let's write a quick example:

\begin{lstlisting}[language=python]
import sys

if __name__ == '__main__':
    args = sys.argv
    print(args)
\end{lstlisting}

Let's run it !

\begin{lstlisting}[language=bash]
doudoush:~$ python3 sys_module.py marie deniiise
  ['sys_module.py', 'marie', 'deniiise']
doudoush:~$
\end{lstlisting}

Remember what I said? All arguments that are given to Python. The file to execute
is an argument. So when you run a Python script, it will always be the first argument
in ``sys.argv''. But as you can see, we got ``marie'' and ``deniiise'' as two different
arguments (as they were separated by a space). Now let's use some other arguments:

\begin{lstlisting}[language=bash]
doudoush:~$ python3 sys_module.py 3 True 25.0
  ['sys_module.py', '3', 'True', '25.0']
doudoush:~$
\end{lstlisting}

As you can see, no matter what you enter as argument, ``sys.argv'' will always
have the string representation of the arguments. Here, we would need to explicitly
cast the variables if we want them in a different type. Let's modify a bit our
jukebox from earlier:

\begin{lstlisting}[language=python]
import sys
from song import powerpuff_song, posca_song

def jukebox(track):
    if track == 1:
        powerpuff_song()
    elif track == 2:
        posca_song()
    else:
        print('We only have two songs for now !')


if __name__ == '__main__':
    args = sys.argv

    if len(args) != 2:
        print('Usage: python3 new_jukebox.py <track>')
        exit(1)

    track = args[1]
    if not track.isdigit():
        print('Error: track must be an int, not', track)
        exit(2)

    print('Running jukebox!')
    jukebox(int(track))
\end{lstlisting}

So basically here, we first checked if there were only two elements in the args
list (remember the first one is the name of the python file). If it's not the case,
we print an error message and exit the program with the error code 1. Then, we use
the ``isdigit'' function (method actually, we'll see that later) of the string
to check if the string represents a number. If it's not the case we print an error
message as well and exit with error code 2. Finally, if everything went well, we
cast the ``track'' string to int, and call the jukebox function. Note that this
is not the perfect way to check if we can cast a string to an int, but we will see
the correct method later on. Let's now run our new jukebox and check the return codes.
Remember that the ``\$?'' variable in bash contains the exit code of the last command.

\begin{lstlisting}[language=bash]
doudoush:~$ python3 new_jukebox.py
  Usage: python3 new_jukebox.py <track>
doudoush:~$ echo $?
  1
doudoush:~$ python3 new_jukebox.py poscaaaa
  Error: track must be an int, not poscaaaa
doudoush:~$ echo $?
  2
doudoush:~$ python3 new_jukebox.py 3 15
  Usage: python3 new_jukebox.py <track>
doudoush:~$ echo $?
  1
doudoush:~$ python3 new_jukebox.py 2
  Running jukebox!
  POSCA POSCAAAA
  tou toudou tou tou tou touuu
  tou toudou tou tou tou touuu
doudoush:~$ echo $?
  0
doudoush:~$
\end{lstlisting}

\vspace{5mm}

\paragraph{The ``shutil'' module}

Just a few words about the ``shutil'' module, which can be quite convenient when
doing Python scripting. It basically contains all shell utilities like ``cp'', ``mv'',
``rm''...

\begin{itemize}
\item ``shutil.copyfile'' copies a file to another file
\item ``shutil.copy'' copies a file to a file or a directory
\item ``shutil.copytree'' copies a directory to another directory
\item ``shutil.move'' moves a file or a directory
\item ``shutil.which'' gives the path to an executable
\end{itemize}

\vspace{5mm}

That's pretty much all I wanted to say for these modules. Basically, remember that:

\begin{itemize}
\item ``os'' contains utilities for any platform specific functions
\item ``sys'' provides an interface to the command line interpreter
\item ``shutil'' gives easy access to shell functions
\end{itemize}

This tutorial was just meant to explain you the differences between these modules,
what they serve, and basically an idea of where to find if you need something.
Of course, most of the time we just check on StackOverflow, but it's sometimes
faster to know where to find. With time, you will have most of these functions in mind.

\subsubsection{Files}
\subsubsection{Parsing arguments}

\subsection{Exercise 2}
% Write is_prime with error handling
% dynamic load something given as argument
% Implement several restaurants as packages 

\subsection{Data structures}
\subsubsection{List}
\subsubsection{Tuple}
\subsubsection{Set}
\subsubsection{Dict}

\subsection{Arguments and named arguments}

\subsection{Project: myFind}
